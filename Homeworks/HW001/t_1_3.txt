a)
1 k += 1        | 4, k = k + 1
2 i = n         | 2, присвоєння, розпакування n
3 while i > 0:  | 3 * (n + 1)
4   i -= 1      | 4 * n

sum = 7n + 9

b)
1 i = n         | 2
2 while i > 1:  | 3*(floor(log2(n)) + 1)
3   k += 1      | 4*floor(log2(n))
4   i //= 2     | 4*floor(log2(n))

let floor(log2(n)) = m

sum = 2 + 3m + 3 + 4m + 4m = 11m + 5

c)
1 i = 0          | 2
2 while i < n:   | 3 * (n/2 + 1)
3   j = 0        | 2 * (n / 2)
4   while j < n: | 3 * (n/2) * (n/2) + 3(n/2) fixme
5       k += 1   | 4 * (n/2) * (n/2)
6       j += 2   | 4 * (n/2) * (n/2)
7   i += 2       | 4 * (n/2)

let n/2 = m

sum = 2 + 3 + 3m + 2m + 3m^2 + 3m + 4m^2 + 4m^2 + 4m = 11m^2 + 12m + 5

d)
1 i = 0          | 2
2 while i < n:   | 3*(n + 1)
3   j = 0        | 2*n
4   while j<i*i: | 5 * ((n - 1)(2n - 1) / 6) * n + 5        вважатимемо що i дістається 2 рази
5       k += 1   | 4 * (n - 1)(2n - 1)n / 6
6       j += 1   | 4 * (n - 1)(2n - 1)n / 6
7   i += 1       | 4 * n



P.S. 5 line => sum_{i = 1}^{n - 1} i^2 => n(n - 1)(2n - 1) / 6
let ((n - 1)(2n - 1) / 6) * n = m

sum = 2 + 3n + 3 + 2n + 5m + 5 + 4m + 4m + 4n = 10 + 9n + 13m

e)
1 i = 0          | 2
2 while i < n:   | 3*(m + 1)
3   j = 1        | 2*(m + 1)
4   while j < n: | 3 * (m) * (m + 1)
5       k += 1   | (m) * (m) * 4
6       j *= 2   | (m) * (m) * 4
7   i *= 2       | 4*m

// m = ceil(log2(n))

sum = 2 + 3m + 3m^2 + 3m + 8m^2 + 4m = 11m^2 + 10m + 2

f)

1 i = 1          | 2
2 while i < n:   | 3 * (m + 1)
3   j = i        | 2 * m
4   while j < n: | 3 * m * (1 + m) / 2 + 3 <- арифм регресія) sum_{i = 1}^{log{2}(n)} i = log{2}(n)(log{2}(n) + 1)/2
5       k += 1   | 4 * m * (1 + m) / 2
6       j *= 2   | 4 * m * (1 + m) / 2
7   i *= 2       | 4 * m

// m = log2(n) округлений в більшу сторону
sum = 2 + 3m + 3+ 2m + 3m + (1 + m) / 2 + 3 + 4m(1 + m) + 4m =
= 8 + 12m + 4m(1 + m) + 3m(1 + m)/2  = 8 + 12m + (7/2)m(1 + m)
